start:
- { type: IntRange, from: 1, to: "{range}", collect: false, streamTarget: getPage }

getPage:
- { f: IntToString, string: page, integer: "{i}" }
- { f: HttpRequest, url: "{url}{page}", put: body, goTo: processPage }

processPage:
# get outer HTML of all title <a>'s
- type: HtmlCssQuery 
  html: "{body}"
  put: "outer-html"
  elementOutput: OUTERHTML
  query: "a.storylink"
  collect: false
  streamTarget: checkLink

checkLink: 
# extract title
- { f: HtmlCssQuery, html: "{outer-html}", put: "title", elementOutput: TEXT, query: "a" }
- { f: HtmlCssQuery, html: "{outer-html}", put: "hreflink", elementOutput: ATTR, attr: href, query: "a" }
- f: MapJoin
  keys:
    match: matches
  list: "{keywords}"
  putElement: keyword
  mapTarget: matchKeyword

- { f: BooleanOp, op: OR, list: "{matches}", result: matched, defaultValue: false }
- { f: IfThenElse, condition: "{matched}", trueTarget: matchedPost }

matchedPost:
- { f: Hash, content: "{{title}}[0]", output: "hash" }
- type: PersistentDuplicateCheck
  persistentStore: "store"
  appendIfNotFound: "{hash}"
  content: "{hash}"

- { f: IfThenElse, condition: "{exists}", falseTarget: not-duplicate-post }

not-duplicate-post:
- type: Telegram
  log: "hello"
  message: "{{title}}[0] ({{hreflink}}[0])"
  recipients:
    - "{recipient}"
  botToken: "{bot-token}"

matchKeyword: 
- { f: ToLowerCase, string: "{{title}}[0]", output: ltitle }
- { f: ToLowerCase, string: "{keyword}", output: lkeyword }
- f: StringContains
  regex: "{lkeyword}"
  content: "{ltitle}"
  output: match
